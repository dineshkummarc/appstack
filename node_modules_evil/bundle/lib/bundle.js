
/*!
 * bundle
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Library version.
 */
 
exports.version = '0.1.6';

/**
 * Module dependencies.
 */
 
var jade = require('jade')
  , fs = require('fs')
  , exec = require('child_process').exec
  , log = require('log')

 /**
 * Exports.
 */
 
exports.Bundle = Bundle;

exports.createBundle = function (opts) {
  return new Bundle(opts);
};

/**
 * Bundle constructor
 *
 * options parameters:
 * - views: templates files default folder
 * - tmp: temporal proccessing folder
 * - gzip: gzip command
 * - 'view engine': view engine
 * - extension: extension file
 * - encoding
 * - tmpPackname: temporal package name
 * - addLogFile: defines add or not a log file
 *
 * @api private
 */
 
function Bundle (opts) {
  // default options
  this.options = {
      views: 'views'
    , tmp: '/tmp'
    , gzip: 'zip'
    , 'view engine': 'jade'
    , extension: 'html'
    , encoding: 'utf8'
    , tmpPackname: 'bundle'
    , addLogFile: true
    , depth: 0
  };

  // mixing options
  for(var k in opts)
    this.options[k] = opts[k];

  // define layouts and partials folders
  this.options.layouts = this.options.layouts || this.options.views;
  this.options.partials = this.options.partials || this.options.layouts;
  
  // initial configs
  this.generated = false;
  this.filename = null;
  this.files = {};
  this.filesCount = 0;

  this.hash = 'node-bundle-' + String(Math.random()).substr(2);

  // create tmpbundle folder
  this.bundlePath = this.options.tmp + '/' + this.hash;
};

/**
 * Defines a file handler.
 *
 * @api private
 */
 
Bundle.prototype.file = function () {
  var args = arguments
    , haveOptions = typeof args[1] == 'object'

  // this fake function is used when file not use render engine
  var fakeFunction = function(a, b){ b(' static: no-template', {}); }
  
  var name = args[0]
    , functionPosition = haveOptions ? 2 : 1
    , fn = typeof args[functionPosition] == 'string'
          ? fakeFunction
          : args[functionPosition]

    , options = haveOptions ? args[1] : {}
    , text = typeof args[functionPosition] == 'string'
                                              ? args[functionPosition]
                                              : false
    , ext = options.extension || this.options.extension;
    
  this.files[name] = {
      name: name
    , fn:fn
    , options: options
    , text: text
    , extension: ext 
  };

  this.filesCount++;
  // debug: \x1B[0;33mbundle: added file ->\x1B[0m \x1B[1;33m\[%j]\x1B[0m \x1B[0;33m%s\x1B[0m, this.filesCount, name + '.' + ext
};

/**
 * Compresses the file.
 *
 * @api private
 */

Bundle.prototype.compress = function (callback) {
  var self = this;

  // make compressed package
  this.filename = this.bundlePath + '/' + this.options.tmpPackname + '.zip';
  var zipCmd = '(cd ' + escape(this.bundlePath) + ' ; '
              + 'zip -r ' + escape(this.options.tmpPackname + '.zip') + ' ./ )'

  self.log('compressing:', zipCmd);

  exec(zipCmd, function (err, stdout, stderr) {
    if (err) return callback(err);
    callback(null, self.filename);
  });
}

/**
 * Generates the structure in a tmp location and gzips it
 *
 * @api private
 */
 
Bundle.prototype.generate = function (params, callback) {
  var self = this;

  // options alias
  var _ops = this.options;

  /**
   * util function createTreePackage()
   * creates the directory tree structure
   *
   * return @param {Function} cbTree: callback tree function
   */

  var createTreePackage = function(cbTree) {
    // create tmpbundle folder
    self.bundlePath = _ops.tmp + '/' + self.hash;
    self.createFolder(self.bundlePath, function(err, folder) {
      if (err) return cbTree(err);

      self.log('create tmp folder:', self.bundlePath);

      cbTree();
    });
  }

  /**
   * util function renderLayout()
   * render layout decoration
   *
   * @param {String} layout: layout name
   * @param {Object} opts: options object
   *
   * return @param {Function} cbLayout: callback layout function
   */

  var renderLayout = function(layout, opts, html, cbLayout) {
    if (!layout) return cbLayout(null);
    delete opts.layout;
    
    var layoutFilename =_ops.layouts + layout
      , options = {
          body: html
        }

    // mixing options
    for(var k in opts)
      options[k] = opts[k];
    
    jade.renderFile(layoutFilename, { locals: options }, function(err, html) {
      if (err) return cbLayout(err);
      self.log('rendering layout:', layoutFilename);

      // debug: \x1B[0;33mbundle: ren layout\x1B[0m \x1B[1;33m\%s\x1B[0m , layout
      return cbLayout(null, html);
    });
  }


  // if this.generated = true calls immediately with this.filename
  // gzips it
  // calls the function with the file location
  if (self.generated) {
    // debug: \x1B[0;33mbundle: package was previsouly generated\x1B[0m
    callback(null, self.filename);
  } else {
    createTreePackage(function() {
      var fileCounter = self.filesCount;

      // outputs everything to a temporary directory (by calling all the file
      // routes in paralell and keeping a counter of completion)
      for (var filename in self.files) {

        (function (file) {
          var saveFilename = self.bundlePath + '/' + file.name
                              + '.' + file.extension
            , templateCounter = 1
            , withPartials = false
            , renderedFile = '';

          // execute file function
          file.fn(params, function(template, options) {

            // partial elements
            var rendersStack = {}
              , renNumber = 0
              , seed = 'partial-' + (0|Math.random()*1e10)
              , getId = function(n) { return seed + '-' + n; }
 
            // partial rendering function
            options.partial = function(){
              withPartials = true;
              templateCounter++;

              var args = arguments
                , name = args[0]
                , callback = typeof args[1] == 'function' ? args[1] : args[2]
                , locals = typeof args[1] == 'object' ? args[1] : {}

              // mixing options
              for(var k in options)
                locals[k] = options[k];

              var renderId = getId(renNumber);
              renNumber++;

              var partialFilename = _ops.partials + name + '.'
                                    + _ops['view engine'];

              jade.renderFile(partialFilename
              , { locals: locals }
              , function(err, html) {
                if (err) return saveFile(err);


                // debug: \x1B[0;33mbundle: ren partial\x1B[0m \x1B[1;33m\%s\x1B[0m , partialFilename

                rendersStack[renderId] = {html: html}
                --templateCounter || saveFile();
              });

              return '{' + renderId + '}';
            }

            var saveFile = function (err) {
              if (err) return callback(err);

              // replace partials
              if (withPartials)
                for(var id in rendersStack)
                  renderedFile = renderedFile.replace('{' + id + '}'
                                  , rendersStack[id].html);

              fs.writeFile(saveFilename, renderedFile, _ops.encoding, function(err) {
                if (err) return callback(err);

                self.log('save file:', saveFilename);
                --fileCounter || (function () {
                  self.generated = true;
                  self.compress(callback);
                })();
              });
            }

            var renderFile = function (name, options, file, callback) {
              if (file.text) return callback(null, file.text);

              // debug: \x1B[0;33mbundle: ren file\x1B[0m \x1B[1;33m\%s\x1B[0m , name

              jade.renderFile(name, options, callback);
            }

            var viewsFilename =_ops.views + template;
            // render html file
            renderFile(viewsFilename
            , { locals: options }
            , file, function(err, html) {
              if (err) return callback(err);

              self.log('render file:', viewsFilename);

              renderLayout(file.options.layout
              , options
              , html
              , function(err, htmlLayout) {
                if (err) return callback(err);

                renderedFile = html;

                // replace html by htmlLayout
                if (htmlLayout) {
                  renderedFile = htmlLayout;
                  self.log('decoration: insert html into layout');
                }
              
                // create folders for file ?
                var rePath = file.name.match(/(.+)\/(.*$)/)
                  , addFolder = rePath ? self.bundlePath + '/' + rePath[1] : false;

                self.createFolder(addFolder, function(err, folder) {
                  if (err) return callback(err);

                  // save html in file (without partials)
                  --templateCounter || saveFile();
                });
              });
            });
          });

        })(self.files[filename]);

      };

    });

  }
};

/**
 * Generates a bundle and saves it to a custom file
 *
 * @api private
 */
 
Bundle.prototype.save = function (params, customFile, callback) {
  var self = this;
  
  this.generate(params, function(err, file){
    if (err) return callback(err);

    var withPath = customFile.match(/[\w|\/].*\//)
      , path = withPath.length
                ? withPath[0].substr(0, withPath[0].length - 1)
                : null;

    self.createFolder(path, function(err, folder) {
      if (err) return callback(err);
      var mvFileCmd = 'mv ' + escape(self.filename) + ' ' + customFile;

      exec(mvFileCmd, function (err, stdout, stderr) {
        if (err) return callback(err);

        self.log('moving file:', mvFileCmd);

        callback(null, customFile);
      });

    });

  });
};

/**
 * Generates a bundle and gets the buffer
 *
 * @param private
 */
 
Bundle.prototype.get = function (params, callback) {
  var self = this;
  this.generate(params, function() {

    // reads the file ...
    fs.readFile(self.filename, function(err, data) {
      if (err) return callback(err);

      // sets this.generated = false
      self.generated = false;

      // removes the file
      exec('rm ' + escape(self.bundlePath) + ' -R', function (err, stdout, stderr) {
        if (err) return callback(err);
        
        // ... and passes the buffer to fn
        callback(null, data);
      });
      
    });

  });

};

/**
 * log() util method
 *
 * @api private
 */
 
Bundle.prototype.log = function () {
  if (!this.options.addLogFile) return null;
  
  if (!this.objLog)
    this.objLog = new log(log.INFO
        , fs.createWriteStream(this.bundlePath + '/'
          + this.options.tmpPackname
          + '.log'));
  
  this.objLog.info(Array.prototype.join.call(arguments, ' '));
}

/**
 * createFolder() util method
 *
 * @api private
 */

Bundle.prototype.createFolder = function(path, fn) {
  if (!path) return fn(null, '');

  exec('mkdir ' + escape(path) + ' -p', function (err, stdout, stderr) {
    if (err) return fn(err);
    fn(null, path);
  });
}

/**
 * Creates a temporary folder.
 *
 * @api private
 */
 
Bundle.prototype.cleanTmpFolder = function (callback) {
  if(!callback) return;
  var self = this;

  exec('rm ' + escape(this.bundlePath) + ' -R', function(err, stdout, stderr) {
    if (err) return callback(err);
    if (stderr) return callback(err, stderr);

    // sets this.generated = false
    self.generated = false;

    self.filesCount = 0;
    self.files = [];
    self.files.length = 0;

    if (callback) callback();
  })
}

/**
 * Escape the given shell `arg`.
 *
 * @param {String} arg
 * @return {String}
 * @api private
 */

function escape (arg) {
  return '"' + String(arg).replace(/"/g, '\\"') + '"';
};

